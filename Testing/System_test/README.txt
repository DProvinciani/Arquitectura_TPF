Para comprobar el correcto funcionamiento del pipeline se realizaron cuatro tests.
En este directorio se encuentran los archivos de codigo fuente en assembler junto al archivo .bit.

Para probar cualquier de los tres tests se debera cargar el archivo .bit a la placa.

Para generar nuevamente el .bit de un test en particular se debe construir el .coe a traves del codigo en assembler
utilizando el compilador provisto en el proyecto. Luego cargar el archivo .coe en el ipcore de instrucciones y
dataMemory.coe en el ipcore de memoria de datos, dentro del ISE.


######################################################################
TEST 1

Codigo			Operacion

NOP ;			//Comienza con un NOP a los fines de que funcione correctamente la interfaz grafica del debugger
LW $17, 0($16);		//2 -> $17 (carga un 2 en el registro 20)
LW $18, 4($16);		//3 -> $18
LW $19, 8($16);		//5 -> $19
LW $20, 12($16);	//7 -> $20	
ADD $22, $17, $18;	//2 + 3 = 5 -> $22  
OR  $23, $18, $17;	//010 || 011 = 011 -> $23
AND $24, $17, $19;	//010 || 101 = 000 -> $24
SUB $25, $19, $20;	//5 - 7 = -2 -> $25

En este test_1 se prueba:
	
	Hazards: ninguno
	Instrucciones: LW, ADD, OR, AND, SUB

Estado final de los registros:

	reg_17 = 2
	reg_18 = 3
	reg_19 = 5
	reg_20 = 7
	reg_22 = 5
	reg_23 = 3
	reg_24 = 0
	reg_25 = -2
	Todos los demas: 0


######################################################################
TEST 2

Codigo			Linea		Operacion

LW $19, 4($16); 	0		//3 -> $19 (carga un 3 en el reg 19)
LW $18, 8($16);				//5 -> $18
LW $20, 12($16);			//7 -> $20
LW $25, 20($16); 	12 		//62 -> $25
LW $26, 16($16);			//80 -> $26
LW $17, 0($16);  	20		//2 -> $17
AND $21, $17, $19;			//2 & 3 = 2 -> $21
OR  $22, $18, $17; 	28		//5 | 2 = 7 -> $22 
SUB $23, $25, $17;			//62 - 2 = 60 -> $23
JR  $23;  36				//jump a 60
AND $16, $21, $19; 	40
AND $16, $22, $19;
AND $16, $23, $19; 	48
AND $16, $17, $19; 
AND $16, $20, $19; 	56
JR  $26;		60		//jump a 80	
AND $16, $21, $19; 	64
AND $16, $22, $19;
AND $16, $23, $19; 	72
AND $16, $20, $19; 
AND $24, $20, $18; 	80		//7 & 5 = 5 -> $24
BEQ $24, $18, 4;  	84		//$24 == $18 (5 == 5) ? salto a 104  (se toma el salto)
J 20; 			88
J 32;
J 64;
J 160;
BEQ $26, $25, 5; 	104 		//$26 == $25 (80 == 62) ? salto 108  (el salto no se toma)
AND $16, $21, $19; 	108 		//2 & 3 = 2 -> $16
AND $16, $22, $19; 	112		//7 & 3 = 3 -> $16
AND $16, $23, $19; 	116		//60 & 3 = 0 -> $16
AND $16, $20, $19; 	120		//7 & 3 = 3 -> $16
OR  $22, $18, $17; 	124		//5 | 2 = 7 -> $22
SUB $23, $25, $17; 	128		//62 - 2 = 60 -> $23
J 37; 			132		//jump a 148 
AND $16, $21, $19; 	136
AND $16, $22, $19; 	140
AND $16, $23, $19; 	144
ADD $16, $25, $26; 	148 		//62 + 80 = 142 -> $16
AND $19, $20, $18; 	152		//7 & 5 = 5 -> $19
BNE $16, $19, 4; 	156 		//$16 != $19 (142 != 5) ? salto a 176 (el salto se toma)
J 20; 			160
J 12; 			164
J 64; 			168
J 4; 			172
BNE $20, $22, 4; 	176 		$20 = 7 == $22 = 7 ? no! sigue a 180
AND $16, $21, $19; 	180 		$16 = 2 & 5 = 0
AND $16, $22, $19; 	184 		$16 = 7 & 5 = 5
AND $16, $23, $19; 	188		$16 = 60 & 5 = 0	
ADD $16, $25, $26; 	192		$16 = 62 + 80 = 142
AND $19, $20, $18; 	196		$19 = 7 | 5 = 5

En test_2 se prueba:

	Hazards:
		Stall para LW
		Stall para BEQ y BNE
	Instrucciones:
		LW, AND, OR, SUB, J, JR, BEQ, BNE

Estado final de los registros:
	
	reg_16 142
	reg_17 2
	reg_18 5
	reg_19 5
	reg_20 7
	reg_21 2
	reg_22 7
	reg_23 60
	reg_24 5
	reg_25 62
	reg_26 80
	Todos los demas: 0


######################################################################
TEST 3

Codigo			Operacion

NOP ;
LW $1, 0($0);		//2 -> $1
LW $2, 4($0);		//3 -> $2
LW $3, 8($0);		//5 -> $3
LW $4, 12($0);		//7 -> $4
LW $5, 24($0);		//10000000_00000000_00000000_00000001 -> $5
SLL $10, $5, 4;		//00000000_00000000_00000000_00010000 -> $10
SRL $11, $5, 4;		//00001000_00000000_00000000_00000000 -> $11
SRA $12, $5, 4;		//11111000_00000000_00000000_00000000 -> $12
SLLV $13, $5, $2;	//00000000_00000000_00000000_00001000 -> $13
SRLV $14, $5, $2;	//00010000_00000000_00000000_00000000 -> $14
SRAV $15, $5, $2;	//11110000_00000000_00000000_00000000 -> $15
ADD $16, $4, $2;	//7 + 3 = 10 -> $16
SUB $17, $16, $2;	//10 - 3 = 7 -> $17
AND $18, $17, $16;	//0111 & 1010 = 2 -> $18 		
OR $19,	$18, $16;	//0010 | 1010 = 10 -> $19
XOR $20, $1, $3;	//010 xor 101 = 111 (7) -> $20
NOR $21, $1, $3;	//00000000_00000000_00000000_00000010 nor 00000000_00000000_00000000_00000101 = 1...1_11111000 (-8) -> $21
SLT $22, $1, $3;	//2 < 5 = 1 -> $22
SLT $23, $3, $1;	//5 < 2 = 0 -> $23

En test_3 se prueban todas las instrucciones tipo-R

Estado final de los registros:

	reg_1	2
	reg_2	3
	reg_3	5
	reg_4	7
	reg_5	10000000_00000000_00000000_00000001
	reg_10	00000000_00000000_00000000_00010000
	reg_11	00001000_00000000_00000000_00000000
	reg_12	11111000_00000000_00000000_00000000
	reg_13	00000000_00000000_00000000_00001000
	reg_14	00010000_00000000_00000000_00000000
	reg_15	11110000_00000000_00000000_00000000
	reg_16	10
	reg_17	7
	reg_18	2
	reg_19	10
	reg_21	7
	reg_22	1
	reg_23	0
	

######################################################################
TEST 4

Codigo			Operacion

LB $1, 28($0);		//11111111_11111111_11111111_10000000 -> $1
LH $2, 28($0);		//11111111_11111111_11000000_10000000 -> $2
LW $3, 28($0);		//11110000_11100000_11000000_10000000 -> $3
LBU $4, 28($0);		//00000000_00000000_00000000_10000000 -> $4
LHU $5, 28($0);		//00000000_00000000_11000000_10000000 -> $5
LWU $6, 28($0);		//11110000_11100000_11000000_10000000 -> $6
SB $6, 32($0);		//00000000_00000000_00000000_10000000 -> memoria
SH $6, 36($0);		//00000000_00000000_11000000_10000000 -> memoria
SW $6, 40($0);		//11110000_11100000_11000000_10000000 -> memoria
ADDI $10, $4, 2;	//130 -> $10
ANDI $11, $4, 129;	//128 -> $11
ORI $12, $4, 1;		//129 -> $12
XORI $13, $4, 129;	//1 -> $13
LUI $14, 1;		//00000000_00000001_00000000_00000000 -> $14  
SLTI $15, $4, 129;	//1 -> $15
LW $7, 32($0);		//00000000_00000000_00000000_10000000 -> $7
LW $8, 36($0);		//00000000_00000000_11000000_10000000 -> $8
LW $9, 40($0);		//11110000_11100000_11000000_10000000 -> $9

En este test se prueban instrucciones tipo-I
	
Estado final de los registros:
	
	reg_1	11111111_11111111_11111111_10000000
	reg_2	11111111_11111111_11000000_10000000
	reg_3	11110000_11100000_11000000_10000000
	reg_4	00000000_00000000_00000000_10000000
	reg_5	00000000_00000000_11000000_10000000
	reg_6	11110000_11100000_11000000_10000000
	reg_7	00000000_00000000_00000000_10000000
	reg_8	00000000_00000000_11000000_10000000
	reg_9	11110000_11100000_11000000_10000000
	reg_10	130
	reg_11	128
	reg_12	129
	reg_13	1
	reg_14	00000000_00000001_00000000_00000000
	reg_15	1


